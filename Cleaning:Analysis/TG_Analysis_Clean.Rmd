---
title: "TG_Analysis_CleanVersion"
output: html_document
date: "2025-03-04"
editor_options: 
  chunk_output_type: console
---
# Setup
```{r setup, echo=FALSE, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
# Load packages
library(tidyverse); library(PupillometryR); library(here); library(dplyr); library(data.table); library(janitor); library(pracma); library(stringr); library(ggplot2); library(ggbeeswarm); library(ggfittext); library(zoo); library(lme4); library(lmerTest); library(sjPlot); library(caret); library(gghalves); library(ggforce); library(ggdist)

# Code chunk Ariel wrote to make graphs look better than the default R version
theme_Publication <- function(base_size=18, base_family="Helvetica") {
  library(grid); library(ggthemes)
  (theme_foundation(base_size=base_size, base_family=base_family)
    + theme(plot.title = element_text(face = "bold",size = rel(1.2), hjust = 0.5),
            text = element_text(),panel.background = element_rect(colour = NA), plot.background = element_rect(colour = NA),
            panel.border = element_rect(colour = NA),axis.title = element_text(face = "bold",size = rel(1)),
            axis.title.y = element_text(angle=90,vjust =2),axis.title.x = element_text(vjust = -0.2),
            axis.text = element_text(), axis.line = element_line(colour="black"),axis.ticks = element_line(),
            panel.grid.major = element_blank(),panel.grid.minor = element_blank(),
            legend.position = "right", legend.direction = "vertical", legend.key.size= unit(0.8, "cm"),
            legend.title = element_text(face="bold"), legend.key = element_rect(colour = NA), plot.margin=unit(c(10,5,5,5),"mm"),
            strip.background=element_rect(colour="#f0f0f0",fill="#f0f0f0"),strip.text = element_text(face="bold")))
}

format_p <- function(pval){
  if(pval < 0.001){"< .001"} else if(pval < 0.009){str_remove(round(pval,3), "^0+")} else {str_remove(round(pval,2), "^0+")}
}

# for raincloud plots
geom_flat_violin <-
  function(mapping = NULL,
           data = NULL,
           stat = "ydensity",
           position = "dodge",
           trim = TRUE,
           scale = "area",
           show.legend = NA,
           inherit.aes = TRUE,
           ...) {
    layer(
      data = data,
      mapping = mapping,
      stat = stat,
      geom = GeomFlatViolin,
      position = position,
      show.legend = show.legend,
      inherit.aes = inherit.aes,
      params = list(trim = trim,
                    scale = scale,
                    ...)
    )
  }

"%||%" <- function(a, b) {
  if (!is.null(a))
    a
  else
    b
}

GeomFlatViolin <-
  ggproto(
    "GeomFlatViolin",
    Geom,
    setup_data = function(data, params) {
      data$width <- data$width %||%
        params$width %||% (resolution(data$x, FALSE) * 0.9)
      
      # ymin, ymax, xmin, and xmax define the bounding rectangle for each group
      data %>%
        group_by(group) %>%
        mutate(
          ymin = min(y),
          ymax = max(y),
          xmin = x,
          xmax = x + width / 2
        )
    },
    
    draw_group = function(data, panel_scales, coord) {
      # Find the points for the line to go all the way around
      data <- transform(data,
                        xminv = x,
                        xmaxv = x + violinwidth * (xmax - x))
      
      # Make sure it's sorted properly to draw the outline
      newdata <- rbind(plyr::arrange(transform(data, x = xminv), y),
                       plyr::arrange(transform(data, x = xmaxv),-y))
      
      # Close the polygon: set first and last point the same
      # Needed for coord_polar and such
      newdata <- rbind(newdata, newdata[1,])
      
      ggplot2:::ggname("geom_flat_violin",
                       GeomPolygon$draw_panel(newdata, panel_scales, coord))
    },
    
    draw_key = draw_key_polygon,
    
    default_aes = aes(
      weight = 1,
      colour = "grey20",
      fill = "white",
      size = 0.5,
      alpha = NA,
      linetype = "solid"
    ),
    
    required_aes = c("x", "y")
  )
# For bootstrapping 95% confidence intervals -- from Mike Frank https://github.com/langcog/KTE/blob/master/mcf.useful.R
library(bootstrap)
theta <- function(x,xdata,na.rm=T) {mean(xdata[x],na.rm=na.rm)}
ci.low <- function(x,na.rm=T) {
  quantile(bootstrap(1:length(x),1000,theta,x,na.rm=na.rm)$thetastar,.025,na.rm=na.rm)} 
ci.high <- function(x,na.rm=T) {
  quantile(bootstrap(1:length(x),1000,theta,x,na.rm=na.rm)$thetastar,.975,na.rm=na.rm) } 
```
# Load cleaned data from the data cleaning script
```{r clean data, echo=FALSE, include=FALSE}
#for knitting
#all_data <- read.csv("/Users/baharsener/Library/CloudStorage/OneDrive-UW/Studies - LCD Lab/TripletGame/Analysis/allData.csv", row.names = 1)
#all_recall_clean <- read.csv("/Users/baharsener/Library/CloudStorage/OneDrive-UW/Studies - LCD Lab/TripletGame/Analysis/all_recall_clean.csv", row.names = 1)

all_data <- read.csv("Analysis/allData.csv", row.names = 1)
all_recall_clean <- read.csv("Analysis/all_recall_clean.csv", row.names = 1)

# Data types change again after reading in the csv, so make sure to make the changes after you load them. 
#all_data
all_data <- all_data %>%
  mutate(across(
    c(orderResponse, trialDirection, trial_category, trialOrder, block, encoding_order, preDecision, block),
    as.factor))

#all_recall_clean
all_recall_clean <- all_recall_clean %>%
  mutate(across(
    c(encoding_order, encoding_position, orderResponse, block, originTrialDir),
    as.factor))

# How many participants
length(unique(all_data$RECORDING_SESSION_LABEL))
length(unique(all_recall_clean$RECORDING_SESSION_LABEL))
```

#1. Recall analysis
###Calculate and visualize memory accuracy by trial direction, across both blocks and separated by blocks
```{r behavioral accuracy, echo=FALSE, include=FALSE, message=FALSE}
# Subject-level accuracy for retrieval trials, grouped by direction
ret_acc_sub <- all_recall_clean %>%
  group_by(RECORDING_SESSION_LABEL, originTrialDir) %>%
  summarise(acc = mean(is_correct))

# Group-level accuracy for retrieval trials, grouped by direction
ret_acc_group <- all_recall_clean %>%
  group_by(originTrialDir) %>%
  summarize(accuracy = mean(is_correct), n = length(originTrialDir), hi = ci.high(is_correct), low = ci.low(is_correct))

# Visualize behavioral accuracy, group:
ret_acc_group$Condition <- "temporal"
ggplot(data = ret_acc_group, aes(x = originTrialDir, y = accuracy, group=Condition)) + geom_line(aes(linetype=factor(Condition)), show.legend = F) + geom_point() + 
  geom_errorbar(aes(max=hi, min=low), width=.2) + ylim(0,1) +
  geom_hline(yintercept = .33, linetype="dashed", alpha=.5) +
  scale_x_discrete(labels = c("LR", "NL", "RL")) + ylab("Accuracy") +xlab("Trial Direction") + theme_Publication() 

# Violin plot
ggplot(data = ret_acc_sub, aes(x = originTrialDir, y = acc)) +
  geom_violin(width = 0.5, outlier.colour = NA, alpha = 0.6, color="black", fill="forestgreen") +
  geom_point(data=ret_acc_group, aes(y = accuracy), fill='white', shape=23, size=4) + 
  geom_quasirandom(width = .15, size = 1, alpha = 1) +
  geom_errorbar(data=ret_acc_group, aes(ymin = low, ymax =hi, y=NULL), width=0) + 
  guides(fill = "none") +
  scale_x_discrete(limits = c("LR","NL", "RL")) +
  geom_hline(yintercept = .33, linetype="dashed", alpha=.5) + 
  ylab("Accuracy") +
  xlab("Trial Direction") + 
  theme_Publication()

# Are there differences in accuracy by trial blocks?
# Subject-level accuracy for retrieval trials, grouped by trial direction and block
ret_acc_block <- all_recall_clean %>%
  group_by(RECORDING_SESSION_LABEL, originTrialDir, block) %>%
  summarise(acc = mean(is_correct)) %>%
  mutate(trialDirection = as.factor(originTrialDir))

# Group-level accuracy for retrieval trials, grouped by direction and block
ret_acc_group_block <- all_recall_clean %>%
  group_by(originTrialDir, block) %>%
  summarize(accuracy = mean(is_correct), n = length(originTrialDir), hi = ci.high(is_correct), low = ci.low(is_correct))


# At or below chance blocks (to look at strategy later)
chance_blocks <- ret_acc_sub %>% filter(acc < 0.34)
length(unique(chance_blocks$RECORDING_SESSION_LABEL)) # How many participants have at least one trial direction that is below chance?
```

### Stats: Trial Direction X Recall Accuracy
```{r accuracy x trial direction, echo=FALSE, include=FALSE}
# Stat check for main effect of trial direction on accuracy
ACC_recall <- glmer(is_correct ~ originTrialDir + (1 | RECORDING_SESSION_LABEL), 
                    family = binomial(link = "logit"), control=glmerControl(optimizer="bobyqa"), 
                    data = all_recall_clean)
summary(ACC_recall)
ref_ACC_recall <- summary(ACC_recall)

# Look at block as well:
ACC_recall_block <- glmer(is_correct ~ originTrialDir + block + (1 | RECORDING_SESSION_LABEL), 
                          family = binomial(link = "logit"), control=glmerControl(optimizer="bobyqa"), 
                          data = all_recall_clean)
summary(ACC_recall_block)
ref_ACC_recall_block <- summary(ACC_recall_block)
```
**Recall Accuracy**
First, we explored participant's behavioral responses during the retrieval phase as a function of the direction in which the triplets were presented during the encoding phase. Participants were significantly less accurate in recalling the temporal order of the images when the triplets were presented from right-to-left ($\beta$ = `r round(ACC_recall_block@beta[2],2)`,  $p$ `r format_p(ref_ACC_recall_block$coefficients[2,4])`) or nonlinearly ($\beta$ = `r round(ACC_recall_block@beta[3],2)`,  $p$ `r format_p(ref_ACC_recall_block$coefficients[3,4])`). There was no difference in accuracy across the two blocks ($\beta$ = `r round(ACC_recall_block@beta[4],2)`,  $p$ `r format_p(ref_ACC_recall_block$coefficients[4,4])`).

###Mistakes people are making by order/position
```{r recall mistakes, echo=FALSE, include=FALSE}
# Add mistake categories to all_recall_clean
all_recall_clean <- all_recall_clean %>%
  mutate(
    mistake_type = case_when(
      encoding_order == "first" & orderResponse == "second" ~ "first->second",
      encoding_order == "first" & orderResponse == "third" ~ "first->third",
      encoding_order == "second" & orderResponse == "first" ~ "second->first",
      encoding_order == "second" & orderResponse == "third" ~ "second->third",
      encoding_order == "third" & orderResponse == "first" ~ "third->first",
      encoding_order == "third" & orderResponse == "second" ~ "third->second",
      TRUE ~ "correct"
    ))

# Make sure it is a factor
all_recall_clean$mistake_type <- as.factor(all_recall_clean$mistake_type)

# Summary of correct and mistakes by subject
recall_answers_sub <- all_recall_clean %>%
group_by(RECORDING_SESSION_LABEL, originTrialDir, encoding_position, encoding_order) %>%
  mutate(total_trials = n()) %>%
  group_by(RECORDING_SESSION_LABEL, originTrialDir, encoding_position, encoding_order, mistake_type, orderResponse) %>%
  summarise(
    count = n(),
    total_trials = first(total_trials), # tot trials for pos/order pair
    .groups = "drop"
  )

# Summary of mistakes made, using proportions because not all order/positions are represented equally
recall_ans_breakdown <- all_recall_clean %>%
  group_by(originTrialDir, encoding_position, encoding_order) %>%
  mutate(total_trials = n()) %>%
  group_by(originTrialDir, encoding_position, encoding_order, mistake_type) %>%
  summarise(
    count = n(),
    total_trials = first(total_trials), # tot trials for pos/order pair
    prop = count/total_trials,
    .groups = "drop"
  )

# Summarize only the mistakes mistakes with proportions, group-level, for both blocks:
mistake_group <- all_recall_clean %>%
  filter(is_correct == 0) %>% 
group_by(originTrialDir, encoding_position, encoding_order) %>%
  mutate(total_trials = n()) %>%
  group_by(originTrialDir, encoding_position, encoding_order, mistake_type) %>%
  summarise(
    count = n(),
    total_trials = first(total_trials), # tot trials for pos/order pair
    prop = count/total_trials,
    .groups = "drop"
  )

# Only the mistakes at group-level, separated by blocks
block_mistake_group <- all_recall_clean %>%
  filter(is_correct == 0) %>% 
group_by(originTrialDir, encoding_position, encoding_order, block) %>%
  mutate(total_trials = n()) %>%
  group_by(originTrialDir, encoding_position, encoding_order, mistake_type, block) %>%
  summarise(
    count = n(),
    total_trials = first(total_trials), # tot trials for pos/order pair
    .groups = "drop"
  )


# Visualize mistakes/prop correct by order and position, across both blocks
ggplot(mistake_group %>% filter(mistake_type != "correct"),
       aes(x = interaction(encoding_position, encoding_order), 
           y = count, fill = mistake_type)) + scale_fill_manual(values = c("#cc2224", "#2daa01","#ff9328","#ef5bf4","#3c5fee","#019e99")) +
  geom_bar(stat = "identity", position = "stack") +
  labs(
    x = "Encoding Position and Order", 
    y = "Count", 
    title = "Proportion of Mistakes by Trial Direction and Encoding Position/Order"
  ) + 
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

#ggsave(
#  "mistakes_prop",
#  plot = last_plot(),
#  device = "tiff",
#  path = "Analysis/Figures",
#  scale = 1,
#  width = NA,
#  height = NA,
#  units = "in",
#  dpi = 300,
#  limitsize = TRUE,
#  bg = NULL
#)

# Create a  table of mistakes (correct answer vs. recall answer)
mistakes_dir <- ftable(all_recall_clean$encoding_position, 
                      all_recall_clean$encoding_order, 
                      all_recall_clean$orderResponse)

mistakes_dir_table <- as.table(mistakes_dir)

# Get proportions
mis_dir_prop <- prop.table(mistakes_dir, 1)
mis_dir_prop <- round(100 * mis_dir_prop, 2)
```

### Stats: Trial Direction X Mistakes, Encoding Position X Mistakes
```{r pairwise comparisons, echo=FALSE, include=FALSE}
# Is encoding position influencing the types of mistakes people are making?
# First compare 'first' and 'third' answers, for images on the left and right.
# Look at just the mistakes:
first_v_third <- all_recall_clean %>%
  group_by(encoding_position, encoding_order, orderResponse) %>%
  mutate(total_trials = n()) %>%
  filter(is_correct == 0, encoding_order != "second", orderResponse != "second", encoding_position != "M") %>%
  group_by(encoding_position, encoding_order, orderResponse) %>%
  summarise(total = first(total_trials), .groups = 'drop')

# People mistakenly recalling 'first' item as third
ans_third <- first_v_third %>% filter(encoding_order == "first") %>%
  select(-encoding_order) %>%  # Remove encoding_position because all are first
  pivot_wider(names_from = orderResponse, values_from = total, values_fill = 0)
  
# People mistakenly recalling 'third' item as first 
ans_first <- first_v_third %>% filter(encoding_order == "third") %>%
  select(-encoding_order) %>%  # Remove encoding_position  because all are third
  pivot_wider(names_from = orderResponse, values_from = total, values_fill = 0)

#Incorrect answers as a 2x2 matrix: if someone responded as first or third, because these are all incorrect answers, it means the 'correct' order was the reverse of the answer!
mistake_2x2 <- matrix(c(ans_first$first, # "first" responses for L and R (when third)
                        ans_third$third),  # "third" responses for L and R (when first)) 
                   nrow = 2, byrow = FALSE,
                   dimnames = list(c("L", "R"), c("ans_first", "ans_third")))

# Fisher test looking at incorrect answers
#mistake_fisher <- fisher.test(mistake_2x2)

# Use chi sq because we have values that are greater than 5!
mistake_chi <- chisq.test(mistake_2x2)
mistake_chi
```
**Recall Errors**
Because participants made more mistakes in the RL and NL trials relative to LR trials, we explored whether participants' mistakes suggested mental organization of temporal order in terms of the mental timeline. For this analysis, we compared  incorrect responses for items presented first and third, on the left or the right side of the screen. Participants were significantly more likely to mistakenly recall an image presented third in the triplet as being presented first when the image was presented on the left side of the screen, relative to when it was presented on the right side of the screen,and were more likely to mistakenly recall an image presented first in the triplet as presented third when the image was presented on the right side of the screen relative to when it was presented on the right side of the screen ($\chi^2$(`r mistake_chi$parameter`) = `r round(mistake_chi$statistic,2)`, $p$ = `r format_p(mistake_chi$p.value)`). These results suggest that the spatial location of the items contribute to participants' recall errors when they are incongruent with the mental timeline.

#2. Encoding pupil dilation
###Encoding Baseline
```{r encoding baseline pupil, echo=FALSE, include=FALSE}
# Use clean df (from the cleaning script)
# for knitting:
#encoding_phase <- read.csv("/Users/baharsener/Library/CloudStorage/OneDrive-UW/Studies - LCD Lab/TripletGame/Analysis/enc_data_relative.csv"", row.names = 1)

enc_data_relative <- read.csv("Analysis/enc_data_relative.csv", row.names = 1)
length(unique(enc_data_relative$RECORDING_SESSION_LABEL))

summary(enc_data_relative)
```
## Method 1: Dilation at first view
###Dilation by trial direction
```{r encoding pup dilation, echo=FALSE, include=FALSE}
#Now that thing have been baselined, I will remove the 'fixation cross' portion from the dataframe so that this portion will not be included in the mean and maximum pupil dilation calculations (because the participants aren't encoding anything during this time). Also remove the first second of first image, but include 500 ms after the third image. 
enc_data_firstview <- enc_data_relative %>%
  filter(new_time > 2950) %>%
  filter(new_time < 8050)

# Visualize relative pupil dilation over the encoding trial after the fixation and before the method question
#ggplot(enc_data_firstview %>% filter(new_time > 2950, new_time < 8050), aes(x=new_time, y = rel_pup, color = as.factor(trialDirection))) + geom_point()
#+ facet_wrap(~RECORDING_SESSION_LABEL)

# Mean relative pupil dilation (not per trial), over time
avg_enc_rel_data <- enc_data_relative %>%
  group_by(new_time, trialDirection, RECORDING_SESSION_LABEL) %>%
  summarise(mean_pup = mean(rel_pup), pup_sd = sd(rel_pup), pup_length = length(rel_pup), 
            pup_sem = pup_sd/sqrt(pup_length), 
            upper_CI = mean_pup + qt(1 - (0.05 / 2), pup_length - 1) * pup_sem,
            lower_CI = mean_pup - qt(1 - (0.05 / 2), pup_length - 1) * pup_sem) %>%
  drop_na()

# Visualize pupil dilation per trial direction per participant
#ggplot(avg_enc_rel_data %>% filter(new_time > 2950, new_time < 8050), aes(x=new_time, y = mean_pup, color = as.factor(trialDirection))) + geom_point() + facet_wrap(~RECORDING_SESSION_LABEL)

# Visualize group-level averaged data, not per trial, over time
enc_group_avg_rel <- avg_enc_rel_data %>%
  group_by(trialDirection, new_time) %>%
  summarise(pupil = mean(mean_pup))

summary(enc_group_avg_rel)

#Plot of pupil dilation during the encoding trial, across both blocks, grouped across participants
#Pink-purple colors are triplet images and yellow is mask
# Visualize only the first view
ggplot(data= enc_group_avg_rel,
       aes(x=new_time, y = pupil, colour=as.factor(trialDirection))) + 
  geom_line() + geom_point() + #facet_wrap(~trialDirection) + 
  annotate("rect", xmin=1800, xmax=2000, ymin=-Inf, ymax=Inf, alpha=0.2, fill="yellow") +
  annotate("text", x=1900, y=0.3 , label = "Fix", size = 2) +
  annotate("rect", xmin=2000, xmax=3500, ymin=-Inf, ymax=Inf, alpha=0.2, fill="blueviolet") +
  annotate("text", x=2750, y=0.3 , label = "Triplet 1", size = 2) + 
  annotate("rect", xmin=4000, xmax=5500, ymin=-Inf, ymax=Inf, alpha=0.2, fill="darkmagenta") +
  annotate("text", x=4750, y=0.3 , label = "Triplet 2", size = 2) + 
  annotate("rect", xmin=6000, xmax=7500, ymin=-Inf, ymax=Inf, alpha=0.2, fill="deeppink1") +
  annotate("text", x=6750, y=0.3 , label = "Triplet 3", size = 2) +
  annotate("rect", xmin=7500, xmax=8000, ymin=-Inf, ymax=Inf, alpha=0.2, fill="orange") +
  annotate("text", x=7800, y=0.3 , label = "Mask", size = 2) +
 ylab("Relative pupil dilation (mm)") + xlab("Time") + labs(colour = "Trial Direction") + ggtitle("Relative Pupil Dilation Over a Trial by Trial Direction") +theme_Publication() + xlim(1800,8050) + ylim(-0.3,0.1)


# Visualize only the first view, only for Block 1
# Participants may have more fatigue effects, and more strategy use during Block 2
enc_avg_rel_block <- enc_data_relative %>%
  group_by(new_time, trialDirection, RECORDING_SESSION_LABEL, block) %>%
  summarise(mean_pup = mean(rel_pup), pup_sd = sd(rel_pup), pup_length = length(rel_pup), 
            pup_sem = pup_sd/sqrt(pup_length), 
            upper_CI = mean_pup + qt(1 - (0.05 / 2), pup_length - 1) * pup_sem,
            lower_CI = mean_pup - qt(1 - (0.05 / 2), pup_length - 1) * pup_sem) %>%
  drop_na()

# Group-level with blocks:
enc_avg_rel_block <- enc_avg_rel_block %>%
  group_by(trialDirection, new_time, block) %>%
  summarise(pupil = mean(mean_pup))

# Visualize just Block 1
ggplot(data= enc_avg_rel_block %>%
         filter(block == 1),
       aes(x=new_time, y = pupil, colour=as.factor(trialDirection))) + 
  geom_line() + geom_point() + #facet_wrap(~trialDirection) + 
  annotate("rect", xmin=1800, xmax=2000, ymin=-Inf, ymax=Inf, alpha=0.2, fill="yellow") +
  annotate("text", x=1200, y=0.3 , label = "Fixation", size = 2) +
  annotate("rect", xmin=2000, xmax=3500, ymin=-Inf, ymax=Inf, alpha=0.2, fill="blueviolet") +
  annotate("text", x=2750, y=0.3 , label = "Triplet 1", size = 2) + 
  annotate("rect", xmin=4000, xmax=5500, ymin=-Inf, ymax=Inf, alpha=0.2, fill="darkmagenta") +
  annotate("text", x=4750, y=0.3 , label = "Triplet 2", size = 2) + 
  annotate("rect", xmin=6000, xmax=7500, ymin=-Inf, ymax=Inf, alpha=0.2, fill="deeppink1") +
  annotate("text", x=6750, y=0.3 , label = "Triplet 3", size = 2) +
  annotate("rect", xmin=7500, xmax=8000, ymin=-Inf, ymax=Inf, alpha=0.2, fill="orange") +
  annotate("text", x=1200, y=0.3 , label = "Mask", size = 2) +
 ylab("Relative pupil dilation (mm)") + xlab("Time") + labs(colour = "Trial Direction") + ggtitle("Relative Pupil Dilation Over a Trial by Trial Direction Block 1") +theme_Publication() + xlim(1800,8050) + ylim(-0.3,0.1)

#ggsave(
#  "first_view_dilB1",
#  plot = last_plot(),
#  device = "tiff",
#  path = "Analysis/Figures",
#  scale = 1,
#  width = NA,
#  height = NA,
#  units = "in",
#  dpi = 300,
#  limitsize = TRUE,
#  bg = NULL
#)

# Visualize just Block 2
# Visualize it
ggplot(data= enc_avg_rel_block %>%
         filter(block == 2),
       aes(x=new_time, y = pupil, colour=as.factor(trialDirection))) + 
  geom_line() + geom_point() + #facet_wrap(~trialDirection) + 
  annotate("rect", xmin=1800, xmax=2000, ymin=-Inf, ymax=Inf, alpha=0.2, fill="yellow") +
  annotate("text", x=1200, y=0.3 , label = "Fixation", size = 2) +
  annotate("rect", xmin=2000, xmax=3500, ymin=-Inf, ymax=Inf, alpha=0.2, fill="blueviolet") +
  annotate("text", x=2750, y=0.3 , label = "Triplet 1", size = 2) + 
  annotate("rect", xmin=4000, xmax=5500, ymin=-Inf, ymax=Inf, alpha=0.2, fill="darkmagenta") +
  annotate("text", x=4750, y=0.3 , label = "Triplet 2", size = 2) + 
  annotate("rect", xmin=6000, xmax=7500, ymin=-Inf, ymax=Inf, alpha=0.2, fill="deeppink1") +
  annotate("text", x=6750, y=0.3 , label = "Triplet 3", size = 2) +
  annotate("rect", xmin=7500, xmax=8000, ymin=-Inf, ymax=Inf, alpha=0.2, fill="orange") +
  annotate("text", x=1200, y=0.3 , label = "Mask", size = 2) +
 ylab("Relative pupil dilation") + xlab("Time") + labs(colour = "Trial Direction") + ggtitle("Relative Pupil Dilation Over a Trial by Trial Direction Block 2") +theme_Publication() + xlim(1800,8050) + ylim(-0.3,0.1)

# Save plot
#ggsave(
#  "first_view_dilB2",
#  plot = last_plot(),
#  device = "tiff",
#  path = "Analysis/Figures",
#  scale = 1,
#  width = NA,
#  height = NA,
#  units = "in",
#  dpi = 300,
#  limitsize = TRUE,
#  bg = NULL
#)

# Check dfs
summary(enc_group_avg_rel)
summary(enc_avg_rel_block)
#Subject-level mean and max pupil dilation by trial direction and block.

sub_enc_pup_trialdir <- enc_data_firstview %>%
  group_by(trialDirection, RECORDING_SESSION_LABEL, block) %>%
  summarise(max_pup = max(rel_pup), mean_pup = mean(rel_pup), pup_sd = sd(rel_pup), pup_length = length(rel_pup), 
            pup_sem = pup_sd/sqrt(pup_length), 
            upper_CI = mean_pup + qt(1 - (0.05 / 2), pup_length - 1) * pup_sem,
            lower_CI = mean_pup - qt(1 - (0.05 / 2), pup_length - 1) * pup_sem) %>%
  drop_na()

# Visualize which parts we are using
ggplot(data= enc_group_avg_rel,
       aes(x=new_time, y = pupil, colour=as.factor(trialDirection))) + 
  geom_line() + geom_point() + #facet_wrap(~trialDirection) + 
#  annotate("rect", xmin=1800, xmax=2000, ymin=-Inf, ymax=Inf, alpha=0.15, fill="black") +
  annotate("text", x=1200, y=0.1, label = "Fixation", size = 2) +
  annotate("rect", xmin=2000, xmax=3500, ymin=-Inf, ymax=Inf, alpha=0.15, fill="blueviolet") +
  annotate("text", x=2750, y=0.1, label = "Triplet 1", size = 2) + 
  annotate("rect", xmin=4000, xmax=5500, ymin=-Inf, ymax=Inf, alpha=0.15, fill="darkmagenta") +
  annotate("text", x=4750, y=0.1, label = "Triplet 2", size = 2) + 
  annotate("rect", xmin=6000, xmax=7500, ymin=-Inf, ymax=Inf, alpha=0.15, fill="deeppink1") +
  annotate("text", x=6750, y=0.1, label = "Triplet 3", size = 2) +
  annotate("rect", xmin=7500, xmax=8000, ymin=-Inf, ymax=Inf, alpha=0.15, fill="black") +
  annotate("text", x=1200, y=0.1, label = "Mask", size = 2) +
  annotate("rect", xmin=3000, xmax=8000, ymin=-Inf, ymax=Inf, alpha=0.2, fill="black") +
  annotate("text", x=5500, y=0.1, label = "Used", size = 4) +
 ylab("Relative pupil dilation") + xlab("Time") + labs(colour = "Trial Direction") + ggtitle("Relative Pupil Used") +theme_Publication() + xlim(1800,8050) + ylim(-0.3,0.1)

#Group-level mean and max pupil dilation by trial direction and block
group_enc_pup_trialdir <- enc_data_firstview %>%
  group_by(trialDirection, block) %>%
  summarise(max_pup = max(rel_pup), mean_pup = mean(rel_pup), pup_sd = sd(rel_pup), pup_length = length(rel_pup), 
            pup_sem = pup_sd/sqrt(pup_length), 
            upper_CI = mean_pup + qt(1 - (0.05 / 2), pup_length - 1) * pup_sem,
            lower_CI = mean_pup - qt(1 - (0.05 / 2), pup_length - 1) * pup_sem) %>%
  drop_na()

# Visualize pupil dilation in two blocks in for the trial directions
ggplot(enc_data_firstview, aes(x = block, y = rel_pup, fill= block)) +
  ggdist::stat_halfeye(
    adjust = .5,
    width = .7,
    justification = -.2, 
    .width = 0,
    point_colour = NA,) +
  geom_boxplot(
    width = .3,
    outlier.color = NA) + 
  facet_wrap(~ trialDirection) +
  labs(title = "Pupil Dilation by Trial Direction and Block",
       x = "Block", y = "Pupil Dilation") + 
  scale_fill_manual(values = c("1" = "#56B4E9", "2" = "#009E73")) +
  theme_Publication()


# Visualize pupil dilation in two blocks in for the trial directions
ggplot(enc_data_firstview, aes(x = trialDirection, y = rel_pup, fill= trialDirection)) +
  ggdist::stat_halfeye(
    adjust = .5,
    width = .7,
    justification = -.2, 
    .width = 0,
    alpha = 0.7,
    point_colour = NA) +
  geom_boxplot(
    width = .3,
    outlier.shape= NA) +  
  labs(title = "Pupil Dilation by Trial Direction",
       x = "Block", y = "Pupil Dilation") + 
  scale_fill_manual(values = c("#d95f02", "#1b9e77", "#7570b3")) +
  theme_Publication()

# Save plot
#ggsave(
#  "first_view_dil_direction",
#  plot = last_plot(),
#  device = "tiff",
#  path = "Analysis/Figures",
#  scale = 1,
#  width = NA,
#  height = NA,
#  units = "in",
#  dpi = 300,
#  limitsize = TRUE,
#  bg = NULL
#)

```
###Stats: Trial Direction X Encoding Pupil Dilation
```{r trial dir x pupil dilation model, echo=FALSE, include=FALSE}
# 1. Mean pupil dilation by trial direction
#rel_pup_dir_model <- lmer(rel_pup ~ trialDirection + (1|RECORDING_SESSION_LABEL), data = enc_data_firstview)
#summary(rel_pup_dir_model)

#I put the whole data here, not mean or max!
encoding_pupil <- enc_data_firstview %>%
  group_by(RECORDING_SESSION_LABEL, TRIAL_INDEX, trialDirection, block) %>%
  summarise(max_pup = max(rel_pup), mean_pup = mean(rel_pup), pup_sd = sd(rel_pup), pup_length = length(rel_pup), 
            pup_sem = pup_sd/sqrt(pup_length), 
            upper_CI = mean_pup + qt(1 - (0.05 / 2), pup_length - 1) * pup_sem,
            lower_CI = mean_pup - qt(1 - (0.05 / 2), pup_length - 1) * pup_sem) %>%
  drop_na()

# 2. Mean pupil dilation by trial direction
#mean_pup_dir_model <- lmer(mean_pup ~ trialDirection + (1|RECORDING_SESSION_LABEL), data = encoding_pupil)
#summary(mean_pup_dir_model)

# 3. Maximum pupil dilation by trial direction
#max_pup_dir_model <- lmer(max_pup ~ trialDirection + (1|RECORDING_SESSION_LABEL), data = encoding_pupil)
#summary(max_pup_dir_model)

# Add block information:
# to the overall:
rel_pup_dir_block <- lmer(rel_pup ~ trialDirection + block + (1|RECORDING_SESSION_LABEL), data = enc_data_firstview)
summary(rel_pup_dir_block)
ref_rel_pup_dir <- summary(rel_pup_dir_block)

# there is a main effect of block, so what about the interaction?
#rel_pup_dir_block_int <- lmer(rel_pup ~ trialDirection * block + (1|RECORDING_SESSION_LABEL), data = enc_data_firstview)
#summary(rel_pup_dir_block_int)
#ref_int_rel_pup_dir <- summary(rel_pup_dir_block_int)
#plot_model(rel_pup_dir_block_int, "int")
#there is also an interaction, block 2 is higher for RL. 

# 5. Mean pupil dilation by trial direction, with block 
mean_pup_dir_block <- lmer(mean_pup ~ trialDirection + block + (1|RECORDING_SESSION_LABEL), data = encoding_pupil)
summary(mean_pup_dir_block)
ref_mean_pup_dir_block <- summary(mean_pup_dir_block)

# 4. Maximum pupil dilation by trial direction, with block 
max_pup_dir_block <- lmer(max_pup ~ trialDirection + block + (1|RECORDING_SESSION_LABEL), data = encoding_pupil)
summary(max_pup_dir_block)
ref_max_pup_dir_block <- summary(max_pup_dir_block)
```
**Pupil Dilation at Encoding Phase**
**During Triplet Viewing**
We compared participant's pupil dilation while viewing the triplets, during the first presentation of the triplet (see figure X). For this analysis, we included pupil values starting from one second after the onset of the first image, and half a second after the end of the third image, corresponding to a 5 second period. The reason for the one-second delay is to ensure any effect we observe is in response to the stimuli displayed in the particular trial, because changes in pupil dilation in response to stimuli emerge slowly. For the same reason, we included half a second period after the offset of the third image to capture responses to the third image. Because both mental fatigue and other study factors (e.g., less surprise, building memory strategies) can influence pupil dilation and retrieval accuracy, we used block as a fixed effect in these models. 

Relative to trials displayed from left-to-right, participants experienced significantly larger pupil dilation when trials were displayed from right-to-left ($\beta$ = `r round(rel_pup_dir_block@beta[2],3)`,  $p$ `r format_p(ref_rel_pup_dir$coefficients[2,5])`) or nonlinearly ($\beta$ = `r round(rel_pup_dir_block@beta[3],3)`,  $p$ `r format_p(ref_rel_pup_dir$coefficients[3,5])`). There was a main effect of the block, such that participants had higher pupil dilation during the second block ($\beta$ = `r round(rel_pup_dir_block@beta[4],3)`,  $p$ `r format_p(ref_rel_pup_dir$coefficients[4,5])`). Because there was a main effect of block, we included block as a fixed effect in all future models.

We then analyzed mean and maximum pupil dilation values as a function of trial direction. Mean or maximum pupil dilation values did not change as a function of trial direction (*t*s <`ref_mean_pup_dir_block$coefficients[3,4]`, $p$s > `r format_p(ref_mean_pup_dir_block$coefficients[3,5])`). This pattern of results suggest that differences in pupil dilation for different trial directions may in part be due to different dilation patterns, rather than overall increase in pupil dilation.

##Dilation at encoding by retrieval accuracy
```{r encoding dilation with accuracy, echo=FALSE, include=FALSE}
#Manipulate pupil df to merge with behavioral data (include trial info)
enc_pup_tomerge <- enc_data_firstview %>%
  group_by(TRIAL_INDEX, trialDirection, RECORDING_SESSION_LABEL, block) %>%
  summarise(max_pup = max(rel_pup), mean_pup = mean(rel_pup), pup_sd = sd(rel_pup), pup_length = length(rel_pup), 
            pup_sem = pup_sd/sqrt(pup_length), 
            upper_CI = mean_pup + qt(1 - (0.05 / 2), pup_length - 1) * pup_sem,
            lower_CI = mean_pup - qt(1 - (0.05 / 2), pup_length - 1) * pup_sem) %>%
  drop_na()

# Now I have to manipulate the recall dataframe to be able to merge with the dilation data: renaming originEncodingTrial to TRIAL_INDEX to merge using that (bc the trial index here in this df is the index of the retrieval trial)
recall_tomerge <- all_recall_clean %>%
  select(-c(TRIAL_INDEX)) %>%
  rename(TRIAL_INDEX = originEncodingTrial)

# Make sure variable types match
recall_tomerge$RECORDING_SESSION_LABEL <- as.factor(recall_tomerge$RECORDING_SESSION_LABEL)

# Merge
pupil_acc_encoding <- enc_pup_tomerge %>%
  left_join(recall_tomerge, by = c("RECORDING_SESSION_LABEL", "TRIAL_INDEX"))

pupil_acc_encoding <- pupil_acc_encoding %>%
  filter(!is.na(retrievalImage)) %>%
  select(-c(block.y)) %>%
  rename(block = block.x)

# Sanity check: check if levels are the same before seeing if they match:
if (!all(levels(pupil_acc_encoding$originTrialDir) %in% levels(pupil_acc_encoding$trialDirection))) {
  cat("Levels in 'originTrialDir' not in 'trialDirection':\n",
      setdiff(levels(pupil_acc_encoding$originTrialDir), levels(pupil_acc_encoding$trialDirection)), "\n")
} else {
  cat("All levels in 'originTrialDir' are present in 'trialDirection'.\n")
}

if (!all(levels(pupil_acc_encoding$trialDirection) %in% levels(pupil_acc_encoding$originTrialDir))) {
  cat("Levels in 'trialDirection' not in 'originTrialDir':\n",
      setdiff(levels(pupil_acc_encoding$trialDirection), levels(pupil_acc_encoding$originTrialDir)), "\n")
} else {
  cat("All levels in 'trialDirection' are present in 'originTrialDir'.\n")
}

# There is an unecessary level '.' in trialDirection. Remove it: (droplevels removes unused levels)
pupil_acc_encoding$trialDirection <- droplevels(pupil_acc_encoding$trialDirection)

# Sanity check, print rows where trial direction and origin trial direction columns do not match
pupil_acc_encoding[pupil_acc_encoding$trialDirection != pupil_acc_encoding$originTrialDir, ]
```

###Stats: Trial Direction X Encoding Pupil Dilation x Accuracy
```{r stats for trial direction and pupil dilation, echo=FALSE, include=FALSE}
# These models  account for position in sequence here as well: if it is easier to recall a particular order, it should be accounted for in the model.

# 1. Does mean dilation during encoding predict accuracy?
acc_by_mean_dilation <- glmer(is_correct ~ mean_pup * trialDirection + encoding_order + block + (1|RECORDING_SESSION_LABEL), 
                              family = binomial(link = "logit"), control = glmerControl(optimizer="bobyqa"), 
                              data = pupil_acc_encoding)

summary(acc_by_mean_dilation)
ref_acc_mean_dilation <- summary(acc_by_mean_dilation)
plot_model(acc_by_mean_dilation, type = "int")
# Seems to not have an influence, third item is more difficult to recall.

# 2. Does maximum dilation during encoding predict accuracy?
acc_by_max_dilation <- glmer(is_correct ~ max_pup * trialDirection + encoding_order + block + (1|RECORDING_SESSION_LABEL), 
                             family = binomial(link = "logit"), control = glmerControl(optimizer="bobyqa"), 
                             data = pupil_acc_encoding)

summary(acc_by_max_dilation)
plot_model(acc_by_max_dilation, type = "int")
```
**Pupil Dilation at Triplet Viewing and Memory Accuracy**
Next, we explored whether pupil dilation during the encoding phase predicted accuracy at the retrieval phase. In this model, we also included encoding order as a fixed effect, to control for the possibility that item order within the triplet may influence memory accuracy.

Mean and maximum pupil dilation at the encoding phase did not predict accuracy at the retrieval phase ((*t*s < `r round(ref_acc_mean_dilation$coefficients[9,3],2)`,  $p$s > `r format_p(ref_acc_mean_dilation$coefficients[9,4])`).
For both of these models, there was a main effect of encoding order, such that the images presented third in the triplet were less likely to be accurately remembered relative to those presented first in the triplet ($\beta$ = `r round(acc_by_mean_dilation@beta[6],3)`,  $p$ `r format_p(ref_acc_mean_dilation$coefficients[6,4])`). [this value comes from the mean dilation model, should I be reporting this from a separate model or?]. 

## Method 2: Dilation during the mask
###Dilation by trial direction
```{r prep data for mask dilation, echo=FALSE, include=FALSE}
enc_data_mask <- enc_data_relative %>% filter(enc_data_relative$new_time < 10000)

# Visualize relative pupil dilation over the encoding trial after the fixation and before the method question
#ggplot(enc_data_mask %>% filter(new_time > 1950, new_time < 10000), aes(x=new_time, y = rel_pup, color = as.factor(trialDirection))) + geom_point() + facet_wrap(~RECORDING_SESSION_LABEL) 

# Mean relative pupil dilation (not per trial), over time
avg_enc_mask_data <- enc_data_mask %>%
  group_by(new_time, trialDirection, RECORDING_SESSION_LABEL) %>%
  summarise(mean_pup = mean(rel_pup), pup_sd = sd(rel_pup), pup_length = length(rel_pup), 
            pup_sem = pup_sd/sqrt(pup_length), 
            upper_CI = mean_pup + qt(1 - (0.05 / 2), pup_length - 1) * pup_sem,
            lower_CI = mean_pup - qt(1 - (0.05 / 2), pup_length - 1) * pup_sem) %>%
  drop_na()

# Visualize pupil dilation per trial direction per participant
#ggplot(avg_enc_mask_data %>% filter(new_time > 1950, new_time < 10000), aes(x=new_time, y = mean_pup, color = as.factor(trialDirection))) + geom_point() + facet_wrap(~RECORDING_SESSION_LABEL)

# Visualize group-level averaged data, not per trial, over time
enc_group_mask_rel <- avg_enc_mask_data %>%
  group_by(trialDirection, new_time) %>%
  summarise(pupil = mean(mean_pup))

summary(enc_group_mask_rel)

#Plot of pupil dilation during the encoding trial, across both blocks, grouped across participants
#Pink-purple colors are triplet images and yellow is mask
# Visualize only the first view
ggplot(data= enc_group_mask_rel,
       aes(x=new_time, y = pupil, colour=as.factor(trialDirection))) + 
  geom_line() + geom_point() + #facet_wrap(~trialDirection) + 
  annotate("rect", xmin=1800, xmax=2000, ymin=-Inf, ymax=Inf, alpha=0.2, fill="yellow") +
  annotate("text", x=1900, y=0.3 , label = "Fix", size = 2) +
  annotate("rect", xmin=2000, xmax=3500, ymin=-Inf, ymax=Inf, alpha=0.2, fill="blueviolet") +
  annotate("text", x=2750, y=0.3 , label = "Triplet 1", size = 2) + 
  annotate("rect", xmin=4000, xmax=5500, ymin=-Inf, ymax=Inf, alpha=0.2, fill="darkmagenta") +
  annotate("text", x=4750, y=0.3 , label = "Triplet 2", size = 2) + 
  annotate("rect", xmin=6000, xmax=7500, ymin=-Inf, ymax=Inf, alpha=0.2, fill="deeppink1") +
  annotate("text", x=6750, y=0.3 , label = "Triplet 3", size = 2) +
#  annotate("rect", xmin=7500, xmax=9500, ymin=-Inf, ymax=Inf, alpha=0.2, fill="orange") +
#  annotate("text", x=7800, y=40 , label = "Mask", size = 2) +
  annotate("rect", xmin=7500, xmax=9500, ymin=-Inf, ymax=Inf, alpha=0.2, fill="black") +
  annotate("text", x=8200, y=0.3 , label = "Used", size = 3) +
 ylab("Relative pupil dilation") + xlab("Time") + labs(colour = "Trial Direction") + ggtitle("Relative Pupil Dilation Over a Trial by Trial Direction") +theme_Publication() + xlim(1800,10000) + ylim(-0.3,0.3)

# Visualize only the first view, only for Block 1
# Participants may have more fatigue effects, and more strategy use during Block 2
enc_avg_rel_block <- enc_data_relative %>%
  group_by(new_time, trialDirection, RECORDING_SESSION_LABEL, block) %>%
  summarise(mean_pup = mean(rel_pup), pup_sd = sd(rel_pup), pup_length = length(rel_pup), 
            pup_sem = pup_sd/sqrt(pup_length), 
            upper_CI = mean_pup + qt(1 - (0.05 / 2), pup_length - 1) * pup_sem,
            lower_CI = mean_pup - qt(1 - (0.05 / 2), pup_length - 1) * pup_sem) %>%
  drop_na()

# Group-level with blocks:
enc_mask_block <- enc_data_mask %>%
  group_by(trialDirection, new_time, block) %>%
  summarise(mean_pup = mean(rel_pup))

# Visualize just Block 1
ggplot(data= enc_mask_block %>%
         filter(block == 1),
       aes(x=new_time, y = mean_pup, colour=as.factor(trialDirection))) + 
   geom_line() + geom_point() + #facet_wrap(~trialDirection) + 
  annotate("rect", xmin=1800, xmax=2000, ymin=-Inf, ymax=Inf, alpha=0.2, fill="yellow") +
  annotate("text", x=1900, y=40 , label = "Fix", size = 2) +
  annotate("rect", xmin=2000, xmax=3500, ymin=-Inf, ymax=Inf, alpha=0.2, fill="blueviolet") +
  annotate("text", x=2750, y=40 , label = "Triplet 1", size = 2) + 
  annotate("rect", xmin=4000, xmax=5500, ymin=-Inf, ymax=Inf, alpha=0.2, fill="darkmagenta") +
  annotate("text", x=4750, y=40 , label = "Triplet 2", size = 2) + 
  annotate("rect", xmin=6000, xmax=7500, ymin=-Inf, ymax=Inf, alpha=0.2, fill="deeppink1") +
  annotate("text", x=6750, y=40 , label = "Triplet 3", size = 2) +
#  annotate("rect", xmin=7500, xmax=9500, ymin=-Inf, ymax=Inf, alpha=0.2, fill="orange") +
#  annotate("text", x=7800, y=40 , label = "Mask", size = 2) +
  annotate("rect", xmin=7500, xmax=9500, ymin=-Inf, ymax=Inf, alpha=0.2, fill="black") +
  annotate("text", x=8200, y=40 , label = "Used", size = 3) +
 ylab("Relative pupil dilation") + xlab("Time") + labs(colour = "Trial Direction") + ggtitle("Relative Pupil Dilation Over a Trial by Trial Direction Block 1") +theme_Publication() + xlim(1800,10000) + ylim(-0.3,0.3)

#ggsave(
#  "mask_dilationB1",
#  plot = last_plot(),
#  device = "tiff",
#  path = "Analysis/Figures",
#  scale = 1,
#  width = NA,
#  height = NA,
#  units = "in",
#  dpi = 300,
#  limitsize = TRUE,
#  bg = NULL
#)

# Visualize just Block 2
# Visualize it
ggplot(data= enc_mask_block %>%
         filter(block == 2),
       aes(x=new_time, y = mean_pup, colour=as.factor(trialDirection))) + 
  geom_line() + geom_point() + #facet_wrap(~trialDirection) + 
  annotate("rect", xmin=1800, xmax=2000, ymin=-Inf, ymax=Inf, alpha=0.2, fill="yellow") +
  annotate("text", x=1900, y=40 , label = "Fix", size = 2) +
  annotate("rect", xmin=2000, xmax=3500, ymin=-Inf, ymax=Inf, alpha=0.2, fill="blueviolet") +
  annotate("text", x=2750, y=40 , label = "Triplet 1", size = 2) + 
  annotate("rect", xmin=4000, xmax=5500, ymin=-Inf, ymax=Inf, alpha=0.2, fill="darkmagenta") +
  annotate("text", x=4750, y=40 , label = "Triplet 2", size = 2) + 
  annotate("rect", xmin=6000, xmax=7500, ymin=-Inf, ymax=Inf, alpha=0.2, fill="deeppink1") +
  annotate("text", x=6750, y=40 , label = "Triplet 3", size = 2) +
#  annotate("rect", xmin=7500, xmax=9500, ymin=-Inf, ymax=Inf, alpha=0.2, fill="orange") +
#  annotate("text", x=7800, y=40 , label = "Mask", size = 2) +
  annotate("rect", xmin=7500, xmax=9500, ymin=-Inf, ymax=Inf, alpha=0.2, fill="black") +
  annotate("text", x=8200, y=40 , label = "Used", size = 3) +
 ylab("Relative pupil dilation") + xlab("Time") + labs(colour = "Trial Direction") + ggtitle("Relative Pupil Dilation Over a Trial by Trial Direction Block 2") +theme_Publication() + xlim(1800,10000) + ylim(-0.3,0.3)

#ggsave(
#  "mask_dilationB2",
#  plot = last_plot(),
#  device = "tiff",
#  path = "Analysis/Figures",
#  scale = 1,
#  width = NA,
#  height = NA,
#  units = "in",
#  dpi = 300,
#  limitsize = TRUE,
#  bg = NULL
#)

summary(enc_data_mask)
summary(enc_mask_block)
```
###Calculate pupil dilation
```{r encoding pup dilation at mask, echo=FALSE, include=FALSE}
enc_data_mask <- enc_data_mask %>%
  filter(new_time > 7450 & new_time < 9550)

# Now do the calculations
sub_enc_pup_trialdir <- enc_data_mask %>%
  group_by(trialDirection, RECORDING_SESSION_LABEL, block) %>%
  summarise(max_pup = max(rel_pup), mean_pup = mean(rel_pup), pup_sd = sd(rel_pup), pup_length = length(rel_pup), 
            pup_sem = pup_sd/sqrt(pup_length), 
            upper_CI = mean_pup + qt(1 - (0.05 / 2), pup_length - 1) * pup_sem,
            lower_CI = mean_pup - qt(1 - (0.05 / 2), pup_length - 1) * pup_sem) %>%
  drop_na()


#Group-level mean and max pupil dilation by trial direction and block
group_enc_pup_trialdir <- enc_data_mask %>%
  group_by(trialDirection, block) %>%
  summarise(max_pup = max(rel_pup), mean_pup = mean(rel_pup), pup_sd = sd(rel_pup), pup_length = length(rel_pup), 
            pup_sem = pup_sd/sqrt(pup_length), 
            upper_CI = mean_pup + qt(1 - (0.05 / 2), pup_length - 1) * pup_sem,
            lower_CI = mean_pup - qt(1 - (0.05 / 2), pup_length - 1) * pup_sem) %>%
  drop_na()


# Visualize pupil dilation in two blocks in for the trial directions
ggplot(enc_data_mask, aes(x = block, y = rel_pup, fill= block)) +
  ggdist::stat_halfeye(
    ## custom bandwidth
    adjust = .5, 
    ## adjust height
    width = .6, 
    ## move geom to the right
    justification = -.2, 
    ## remove slab interval
    .width = 0, 
    point_colour = NA
  ) + 
  geom_boxplot(
    width = .15, 
    ## remove outliers
    outlier.color = NA ## `outlier.shape = NA` or `outlier.alpha = 0` works as well
  ) +
  facet_wrap(~ trialDirection) +
  labs(title = "Mask Pupil Dilation by Trial Direction and Block",
       x = "Block", y = "Pupil Dilation") +  scale_fill_manual(values = c("1" = "#56B4E9", "2" = "#009E73")) +
  theme_Publication()

#ggsave(
#  "mask_dil_direction",
#  plot = last_plot(),
#  device = "tiff",
#  path = "Analysis/Figures",
#  scale = 1,
#  width = NA,
#  height = NA,
#  units = "in",
#  dpi = 300,
#  limitsize = TRUE,
#  bg = NULL
#)
```

###Stats: Trial Direction X Encoding Pupil Dilation
```{r trial dir x pupil dilation during mask, echo=FALSE, include=FALSE}
# 1. Mean pupil dilation by trial direction
maskpup_dir <- lmer(rel_pup ~ trialDirection + (1|RECORDING_SESSION_LABEL), data = enc_data_mask)
summary(maskpup_dir)

#with block:
maskpup_dir_block <- lmer(rel_pup ~ trialDirection + block + (1|RECORDING_SESSION_LABEL), data = enc_data_mask)
summary(maskpup_dir_block)
ref_maskpup_dir_block <- summary(maskpup_dir_block)

#with interaction
#with block:
maskpup_dir_block_int <- lmer(rel_pup ~ trialDirection * block + (1|RECORDING_SESSION_LABEL), data = enc_data_mask)
summary(maskpup_dir_block_int)
ref_maskpup_dir_block_int <- summary(maskpup_dir_block_int)
plot_model(maskpup_dir_block_int, type = "int")

#I put the whole data here, not mean or max!
encoding_mask_pupil <- enc_data_mask %>%
  group_by(RECORDING_SESSION_LABEL, TRIAL_INDEX, trialDirection, block) %>%
  summarise(max_pup = max(rel_pup), mean_pup = mean(rel_pup), pup_sd = sd(rel_pup), pup_length = length(rel_pup), 
            pup_sem = pup_sd/sqrt(pup_length), 
            upper_CI = mean_pup + qt(1 - (0.05 / 2), pup_length - 1) * pup_sem,
            lower_CI = mean_pup - qt(1 - (0.05 / 2), pup_length - 1) * pup_sem) %>%
  drop_na()

# 2. Mean pupil dilation by trial direction
maskpup_mean <- lmer(mean_pup ~ trialDirection + (1|RECORDING_SESSION_LABEL), data = encoding_mask_pupil)
summary(maskpup_mean)

# 3. Maximum pupil dilation by trial direction
maskpup_max <- lmer(max_pup ~ trialDirection + (1|RECORDING_SESSION_LABEL), data = encoding_mask_pupil)
summary(maskpup_max)

# Add block information:
# 5. Mean pupil dilation by trial direction, with block 
maskpup_mean_block <- lmer(mean_pup ~ trialDirection + block + (1|RECORDING_SESSION_LABEL), data = encoding_mask_pupil)
summary(maskpup_mean_block)

# 4. Maximum pupil dilation by trial direction, with block 
maskpup_max_block <- lmer(max_pup ~ trialDirection + block + (1|RECORDING_SESSION_LABEL), data = encoding_mask_pupil)
summary(maskpup_max_block)
```
**Pupil Dilation at Encoding Phase**
**During Mask**

Next, we explored participant's pupil dilation after viewing the triplets, while the mask image is presented.For this analysis, we included pupil values that included the two seconds after the offset of the third image, while the mask image was presented. The reason for this additional exploration was to assess whether these two time periods, one of actively viewing the images and committing to memory and the other of maintaining in memory, may reveal different patterns. Similar previous analyses, because both mental fatigue and memory strategies can influence pupil dilation and retrieval accuracy, we used block as a fixed effect in these models.

Relative to trials displayed from left-to-right, participants experienced significantly smaller pupil dilation when trials were displayed nonlinearly ($\beta$ = `r round(maskpup_dir_block@beta[2],3)`,  $p$ `r format_p(ref_maskpup_dir_block$coefficients[2,5])`) but not from trials displayed from right-to-left ($\beta$ = `r round(maskpup_dir_block@beta[3],3)`,  $p$ `r format_p(ref_maskpup_dir_block$coefficients[3,5])`). Similar to previous analyses, there was a main effect of block, however, it was in the opposite pattern such that participants had overall lower pupil dilation during the second block ($\beta$ = `r round(maskpup_dir_block@beta[4],3)`,  $p$ `r format_p(ref_maskpup_dir_block$coefficients[4,5])`).

We then analyzed mean and maximum pupil dilation values as a function of trial direction. Trial direction did not influence mean or maximum pupil values during the two seconds following the initial triplet presentations (all t's, all p's values). This pattern of results suggest that differences in pupil dilation for different trial directions may in part be due to different dilation patterns.

###Dilation at encoding by retrieval accuracy
Look at whether dilation at encoding is related to retrieval accuracy
```{r encoding dilation with accuracy mask, echo=FALSE, include=FALSE}
#Manipulate pupil df to merge with behavioral data (include trial info)
enc_pup_tomerge <- enc_data_mask %>%
  group_by(TRIAL_INDEX, trialDirection, RECORDING_SESSION_LABEL, block) %>%
  summarise(max_pup = max(rel_pup), mean_pup = mean(rel_pup), pup_sd = sd(rel_pup), pup_length = length(rel_pup), 
            pup_sem = pup_sd/sqrt(pup_length), 
            upper_CI = mean_pup + qt(1 - (0.05 / 2), pup_length - 1) * pup_sem,
            lower_CI = mean_pup - qt(1 - (0.05 / 2), pup_length - 1) * pup_sem) %>%
  drop_na()

# Now I have to manipulate the recall dataframe to be able to merge with the dilation data: renaming originEncodingTrial to TRIAL_INDEX to merge using that (bc the trial index here in this df is the index of the retrieval trial)
recall_tomerge <- all_recall_clean %>%
  select(-c(TRIAL_INDEX)) %>%
  rename(TRIAL_INDEX = originEncodingTrial)

# Make sure variable types match
recall_tomerge$RECORDING_SESSION_LABEL <- as.factor(recall_tomerge$RECORDING_SESSION_LABEL)

# Merge
pupil_acc_encoding <- enc_pup_tomerge %>%
  left_join(recall_tomerge, by = c("RECORDING_SESSION_LABEL", "TRIAL_INDEX"))

pupil_acc_encoding <- pupil_acc_encoding %>%
  filter(!is.na(retrievalImage)) %>%
  select(-c(block.y)) %>%
  rename(block = block.x)

# Sanity check: check if levels are the same before seeing if they match:
if (!all(levels(pupil_acc_encoding$originTrialDir) %in% levels(pupil_acc_encoding$trialDirection))) {
  cat("Levels in 'originTrialDir' not in 'trialDirection':\n",
      setdiff(levels(pupil_acc_encoding$originTrialDir), levels(pupil_acc_encoding$trialDirection)), "\n")
} else {
  cat("All levels in 'originTrialDir' are present in 'trialDirection'.\n")
}

if (!all(levels(pupil_acc_encoding$trialDirection) %in% levels(pupil_acc_encoding$originTrialDir))) {
  cat("Levels in 'trialDirection' not in 'originTrialDir':\n",
      setdiff(levels(pupil_acc_encoding$trialDirection), levels(pupil_acc_encoding$originTrialDir)), "\n")
} else {
  cat("All levels in 'trialDirection' are present in 'originTrialDir'.\n")
}

# There is an unecessary level '.' in trialDirection. Remove it: (droplevels removes unused levels)
pupil_acc_encoding$trialDirection <- droplevels(pupil_acc_encoding$trialDirection)

# Sanity check, print rows where trial direction and origin trial direction columns do not match
pupil_acc_encoding[pupil_acc_encoding$trialDirection != pupil_acc_encoding$originTrialDir, ]
```

###Stats: Trial Direction X Encoding Pupil Dilation x Accuracy
These models  account for position in sequence here as well
```{r stats: trial direction and pupil dilation, echo=FALSE, include=FALSE}
# 1. Does mean dilation during encoding predict accuracy?
mask_mean_acc <- glmer(is_correct ~ mean_pup * trialDirection + encoding_order + block + (1|RECORDING_SESSION_LABEL), 
                       family = binomial(link = "logit"), control = glmerControl(optimizer="bobyqa"), 
                       data = pupil_acc_encoding)

summary(mask_mean_acc)
ref_mask_mean_acc <- summary(mask_mean_acc)
plot_model(mask_mean_acc, type = "int")

# 2. Does maximum dilation during encoding predict accuracy?
mask_max_acc <- glmer(is_correct ~ max_pup * trialDirection + encoding_order + block + (1|RECORDING_SESSION_LABEL), 
                      family = binomial(link = "logit"), control = glmerControl(optimizer="bobyqa"), 
                      data = pupil_acc_encoding)

summary(mask_max_acc)
plot_model(mask_max_acc, type = "int")

# No effect of mean or max, third image more difficult to recall.
```
**Pupil Dilation at Mask and Memory Accuracy**
Next, we explored whether pupil dilation during the mask phase of the encoding trials predicted accuracy at the retrieval phase. In this model, we also included encoding order as a fixed effect, to control for the possibility that item order within the triplet may influence memory accuracy.

Mean pupil dilation, and maximum pupil dilation did not predict accuracy 
(all t's, all p's values). (in both models) There was a main effect of encoding order, such that the images presented third in the triplet were less likely to be accurately remembered relative to those presented first in the triplet ($\beta$ = `r round(mask_mean_acc@beta[6],3)`,  $p$ `r format_p(ref_mask_mean_acc$coefficients[6,4])`). [this value comes from the mean dilation model]. 

#3. Gaze patterns and accuracy
## Shape retrieval data 
```{r retrieval gaze movements, echo=FALSE, include=FALSE, message=FALSE}
# Using a "pre-decision" phase, for which for one second participants see a blank screen.
#retrieval_phase <- read.csv("/Users/baharsener/Library/CloudStorage/OneDrive-UW/Studies - LCD Lab/TripletGame/Analysis/retrieval_phase.csv", row.names = 1)

retrieval_phase <- read.csv("Analysis/retrieval_phase.csv", row.names = 1)

# Make sure all variables are formatted as we want them
retrieval_phase <- retrieval_phase %>%
  mutate(across(
    c(RECORDING_SESSION_LABEL, orderResponse, trialDirection, trial_category, trialOrder, block, encoding_order, preDecision, block),
    as.factor)) %>%
  mutate(across(
    c(LEFT_GAZE_X, LEFT_GAZE_Y),
    as.numeric))

#  pre-decision phase
preDecision <- retrieval_phase %>%
  filter(new_time > 3450, new_time < 4550)
```

First, look at the gaze patterns right after the retrieval image disappears, and one second after that (before answer options appear). For this, we will look at:
## Overall means
```{r overall means for gaze locations}
gaze_sum_loc <- preDecision %>%
  arrange(RECORDING_SESSION_LABEL, TRIAL_INDEX, new_time) %>%
  filter(!is.na(encoding_position)) %>%
  group_by(encoding_position) %>% 
   summarize(
    mean_gaze_x = mean(LEFT_GAZE_X),
  ) %>%
  drop_na(mean_gaze_x) %>%
  ungroup()

ggplot(gaze_sum_loc, aes(x = mean_gaze_x, y = 1, color = encoding_position)) +
  geom_point(size = 4) +
  labs(x = "Mean Gaze X", y = "", color = "Encoding Pos") + xlim(640, 652) +
  theme_Publication()
  
gaze_sum_order <- preDecision %>%
  arrange(RECORDING_SESSION_LABEL, TRIAL_INDEX, new_time) %>%
  filter(!is.na(encoding_order)) %>%
  group_by(encoding_order) %>% 
   summarize(
    mean_gaze_x = mean(LEFT_GAZE_X),
  ) %>%
  drop_na(mean_gaze_x) %>%
  ungroup()

ggplot(gaze_sum_order, aes(x = mean_gaze_x, y = 1, color = encoding_order)) +
  geom_point(size = 4) +
  labs(x = "Mean Gaze X", y = "", color = "Encoding Order") + xlim(640, 652) +
  theme_Publication()

gaze_sum_all <- preDecision %>%
  arrange(RECORDING_SESSION_LABEL, TRIAL_INDEX, new_time) %>%
  filter(!is.na(encoding_position), !is.na(encoding_order)) %>%
   summarize(
    mean_gaze_x = mean(LEFT_GAZE_X),
  ) %>%
  drop_na(mean_gaze_x) %>%
  ungroup()
```
## 1) Rolling averages of gaze location:
```{r gaze patterns by encoding position, echo=FALSE, include=FALSE}
# Calculate the rolling averages
# Bins of 5 will give us averages over a 1/8th of a second.
retrieval_mean_gaze <- preDecision %>%
  arrange(RECORDING_SESSION_LABEL, TRIAL_INDEX, new_time) %>%
  group_by(RECORDING_SESSION_LABEL, TRIAL_INDEX, encoding_position, encoding_order) %>%  # Group by trial and direction/location
  mutate(
    rolling_gaze_x = rollmean(LEFT_GAZE_X, k = 5, fill = NA, align = "center"),
    rolling_gaze_y = rollmean(LEFT_GAZE_Y, k = 5, fill = NA, align = "center")
  ) %>%
  drop_na(rolling_gaze_x, rolling_gaze_y) %>%
  ungroup()

summary(retrieval_mean_gaze)
retrieval_mean_gaze$encoding_position <- as.factor(retrieval_mean_gaze$encoding_position)

# Visualize gaze location in two blocks for the trial directions
ggplot(retrieval_mean_gaze %>%
         filter(!is.na(originTrialDir)), aes(x = originTrialDir, y = rolling_gaze_x, fill= originTrialDir)) +
  ggdist::stat_halfeye(
    adjust = .5,
    width = .7,
    justification = -.2, 
    .width = 0,
    point_colour = NA,) +
  geom_boxplot(
    width = .3,
    outlier.color = NA) + 
  labs(title = "Gaze Location by Trial Direction",
       x = "Trial Direction", y = "Gaze X Position")  +
  theme_Publication()
```
### Encoding position x gaze location
```{r plots for gaze patterns by encoding position, eval = FALSE, echo=FALSE, include=FALSE}
# Correct trials, group-level:
ggplot(data = retrieval_mean_gaze %>%
         filter(is_correct == 1, !is.na(rolling_gaze_x), !is.na(new_time), !is.na(RECORDING_SESSION_LABEL)) %>%
         group_by(new_time, encoding_position) %>%
         summarize(average_gaze_x = mean(rolling_gaze_x, na.rm = TRUE), .groups = "drop"), 
       aes(x = average_gaze_x, y = new_time, color = encoding_position, group = encoding_position)) +
  geom_line(alpha = 0.7) +  # Transparency for overlapping lines
  geom_smooth(method = "loess", se = FALSE) +  # Smoothing to reduce zigzags
  labs(
    title = "Gaze X Location of Correct Retrieval Trials",
    x = "Gaze X",
    y = "Time (ms)"
  ) +
  theme_Publication()

# Incorrect trials, group-level:
ggplot(data = retrieval_mean_gaze %>%
         filter(is_correct == 0, !is.na(rolling_gaze_x), !is.na(new_time), !is.na(RECORDING_SESSION_LABEL)) %>%
         group_by(new_time, encoding_position) %>%
         summarize(average_gaze_x = mean(rolling_gaze_x, na.rm = TRUE), .groups = "drop"), 
       aes(x = average_gaze_x, y = new_time, color = encoding_position, group = encoding_position)) +
  geom_line(alpha = 0.7) +  # Transparency for overlapping lines
  geom_smooth(method = "loess", se = FALSE) +  # Smoothing to reduce zigzags
  labs(
    title = "Gaze X Location of Incorrect Retrieval Trials",
    x = "Gaze X",
    y = "Time (ms)"
  ) +
  theme_Publication()
# Averaged dot-plot, correct trials: (each dot is an averaged timebin)
ggplot(retrieval_mean_gaze %>%
         filter(is_correct == 1, !is.na(rolling_gaze_x), !is.na(new_time), !is.na(RECORDING_SESSION_LABEL)) %>%
         group_by(new_time, encoding_position) %>%
         summarize(average_gaze_x = mean(rolling_gaze_x, na.rm = TRUE), average_gaze_y = mean(rolling_gaze_y, na.rm = TRUE)),
       aes(x = average_gaze_x, y = average_gaze_y)) +
  geom_point(aes(color = encoding_position), size = 2) +
  coord_cartesian(expand = FALSE) +
  labs(title = "Averaged Gaze Coordinates During Correct Retrieval",
       x = "X Coordinate",
       y = "Y Coordinate") + scale_y_reverse() +
  xlim(620, 675) + #ylim(475, 550) +
  theme_Publication()

# Dot plot by participant, incorrect trials:
ggplot(retrieval_mean_gaze %>%
         filter(is_correct == 0, !is.na(rolling_gaze_x), !is.na(new_time), !is.na(RECORDING_SESSION_LABEL)) %>%
         group_by(new_time, encoding_position) %>%
         summarize(average_gaze_x = mean(rolling_gaze_x, na.rm = TRUE), average_gaze_y = mean(rolling_gaze_y, na.rm = TRUE)),
       aes(x = average_gaze_x, y = average_gaze_y)) +
  geom_point(aes(color = encoding_position), size = 2) +
  coord_cartesian(expand = FALSE) +
  labs(title = "Averaged Gaze Coordinates During Incorrect Retrieval",
       x = "X Coordinate",
       y = "Y Coordinate") + scale_y_reverse() +
  xlim(620, 675) + #ylim(475, 550) +
  theme_Publication() 

# Plots that have time information:
# Correct trials
ggplot(retrieval_mean_gaze %>%
         filter(is_correct == 1, !is.na(rolling_gaze_x), !is.na(new_time), !is.na(RECORDING_SESSION_LABEL)) %>%
         group_by(new_time, encoding_position) %>%
         summarize(average_gaze_x = mean(rolling_gaze_x, na.rm = TRUE), average_gaze_y = mean(rolling_gaze_y, na.rm = TRUE)),
       aes(x = average_gaze_x, y = average_gaze_y)) +
  geom_point(aes(color = new_time), size = 2.5, alpha = 0.7) +  # Changed from encoding_position to new_time
  coord_cartesian(expand = FALSE) +
  facet_wrap(~encoding_position) +
  labs(title = "Averaged Gaze Coordinates During Correct Retrieval",
       x = "X Coordinate",
       y = "Y Coordinate",
       color = "Time") +
  scale_y_reverse() +
  scale_color_viridis_c() + 
 # xlim(620, 675) +
  theme_Publication()

# Incorrect trials
ggplot(retrieval_mean_gaze %>%
         filter(is_correct == 0, !is.na(rolling_gaze_x), !is.na(new_time), !is.na(RECORDING_SESSION_LABEL)) %>%
         group_by(new_time, encoding_position) %>%
         summarize(average_gaze_x = mean(rolling_gaze_x, na.rm = TRUE), average_gaze_y = mean(rolling_gaze_y, na.rm = TRUE)),
       aes(x = average_gaze_x, y = average_gaze_y)) +
  geom_point(aes(color = new_time), size = 2.5, alpha = 0.7) +  # Changed from encoding_position to new_time
  coord_cartesian(expand = FALSE) +
  facet_wrap(~encoding_position) +
  labs(title = "Averaged Gaze Coordinates During Incorrect Retrieval",
       x = "X Coordinate",
       y = "Y Coordinate",
       color = "Time") +
  scale_y_reverse() +
  scale_color_viridis_c() + 
 # xlim(620, 675) +
  theme_Publication()
```

### Encoding order x gaze location:
```{r plots for patterns by encoding order, eval = FALSE, echo=FALSE, include=FALSE}
# Plot
# Correct trials, group-level:
ggplot(data = retrieval_mean_gaze %>%
         filter(is_correct == 1, !is.na(rolling_gaze_x), !is.na(new_time), !is.na(RECORDING_SESSION_LABEL)) %>%
         group_by(new_time, encoding_order) %>%
         summarize(average_gaze_x = mean(rolling_gaze_x, na.rm = TRUE), .groups = "drop"), 
       aes(x = average_gaze_x, y = new_time, color = encoding_order, group = encoding_order)) +
  geom_line(alpha = 0.7) +  # Transparency for overlapping lines
  geom_smooth(method = "loess", se = FALSE) +  # Smoothing to reduce zigzags
  labs(
    title = "Gaze X Location of Correct Retrieval Trials",
    x = "Gaze X",
    y = "Time (ms)"
  ) + 
  theme_Publication()

# Incorrect trials, group-level:
ggplot(data = retrieval_mean_gaze %>%
         filter(is_correct == 0, !is.na(rolling_gaze_x), !is.na(new_time), !is.na(RECORDING_SESSION_LABEL)) %>%
         group_by(new_time, encoding_order) %>%
         summarize(average_gaze_x = mean(rolling_gaze_x, na.rm = TRUE), .groups = "drop"), 
       aes(x = average_gaze_x, y = new_time, color = encoding_order, group = encoding_order)) +
  geom_line(alpha = 0.7) +  # Transparency for overlapping lines
  geom_smooth(method = "loess", se = FALSE) +  # Smoothing to reduce zigzags
  labs(
    title = "Gaze X Location of Incorrect Retrieval Trials",
    x = "Gaze X",
    y = "Time (ms)"
  ) +
  theme_Publication()

# Averaged dor-plot, correct trials: (each dot is an averaged timebin)
ggplot(retrieval_mean_gaze %>%
         filter(is_correct == 1, !is.na(rolling_gaze_x), !is.na(new_time), !is.na(RECORDING_SESSION_LABEL)) %>%
         group_by(new_time, encoding_order) %>%
         summarize(average_gaze_x = mean(rolling_gaze_x, na.rm = TRUE), average_gaze_y = mean(rolling_gaze_y, na.rm = TRUE)),
       aes(x = average_gaze_x, y = average_gaze_y)) +
  geom_point(aes(color = encoding_order), size = 2) +
  coord_cartesian(expand = FALSE) +
  labs(title = "Averaged Gaze Coordinates During Correct Retrieval",
       x = "X Coordinate",
       y = "Y Coordinate") + scale_y_reverse() +
  xlim(620, 700) + #ylim(475, 550) +
  theme_Publication() 

# Dot plot by participant, incorrect trials:
ggplot(retrieval_mean_gaze %>%
         filter(is_correct == 0, !is.na(rolling_gaze_x), !is.na(new_time), !is.na(RECORDING_SESSION_LABEL)) %>%
         group_by(new_time, encoding_order) %>%
         summarize(average_gaze_x = mean(rolling_gaze_x, na.rm = TRUE), average_gaze_y = mean(rolling_gaze_y, na.rm = TRUE)),
       aes(x = average_gaze_x, y = average_gaze_y)) +
  geom_point(aes(color = encoding_order), size = 2) +
  coord_cartesian(expand = FALSE) +
  labs(title = "Averaged Gaze Coordinates During Incorrect Retrieval",
       x = "X Coordinate",
       y = "Y Coordinate") + scale_y_reverse() +
  xlim(620, 700) + #ylim(475, 550) +
  theme_Publication() 

# Plots that have time information:
# Correct trials
ggplot(retrieval_mean_gaze %>%
         filter(is_correct == 1, !is.na(rolling_gaze_x), !is.na(new_time), !is.na(RECORDING_SESSION_LABEL)) %>%
         group_by(new_time, encoding_order) %>%
         summarize(average_gaze_x = mean(rolling_gaze_x, na.rm = TRUE), average_gaze_y = mean(rolling_gaze_y, na.rm = TRUE)),
       aes(x = average_gaze_x, y = average_gaze_y)) +
  geom_point(aes(color = new_time), size = 2.5, alpha = 0.7) +  # Changed from encoding_position to new_time
  coord_cartesian(expand = FALSE) +
  facet_wrap(~encoding_order) +
  labs(title = "Averaged Gaze Coordinates During Correct Retrieval",
       x = "X Coordinate",
       y = "Y Coordinate",
       color = "Time") +
  scale_y_reverse() +
  scale_color_viridis_c() + 
 # xlim(620, 675) +
  theme_Publication()

# Incorrect trials
ggplot(retrieval_mean_gaze %>%
         filter(is_correct == 0, !is.na(rolling_gaze_x), !is.na(new_time), !is.na(RECORDING_SESSION_LABEL)) %>%
         group_by(new_time, encoding_order) %>%
         summarize(average_gaze_x = mean(rolling_gaze_x, na.rm = TRUE), average_gaze_y = mean(rolling_gaze_y, na.rm = TRUE)),
       aes(x = average_gaze_x, y = average_gaze_y)) +
  geom_point(aes(color = new_time), size = 2.5, alpha = 0.7) +  # Changed from encoding_position to new_time
  coord_cartesian(expand = FALSE) +
  facet_wrap(~encoding_order) +
  labs(title = "Averaged Gaze Coordinates During Incorrect Retrieval",
       x = "X Coordinate",
       y = "Y Coordinate",
       color = "Time") +
  scale_y_reverse() +
  scale_color_viridis_c() + 
 # xlim(620, 675) +
  theme_Publication()
```
### Trial direction x Gaze location:
```{r plots for gaze patterns at retrieval by encoding trial direction, eval = FALSE, echo=FALSE, include=FALSE}
# Plot
# Correct trials, group-level:
ggplot(data = retrieval_mean_gaze %>%
         filter(is_correct == 1, !is.na(rolling_gaze_x), !is.na(new_time), !is.na(RECORDING_SESSION_LABEL)) %>%
         group_by(new_time, originTrialDir) %>%
         summarize(average_gaze_x = mean(rolling_gaze_x, na.rm = TRUE), .groups = "drop"), 
       aes(x = average_gaze_x, y = new_time, color = originTrialDir, group = originTrialDir)) +
  geom_line(alpha = 0.7) +  # Transparency for overlapping lines
  geom_smooth(method = "loess", se = FALSE) +  # Smoothing to reduce zigzags
  labs(
    title = "Gaze X Location of Correct Retrieval Trials",
    x = "Gaze X",
    y = "Time (ms)"
  ) +
  theme_Publication()

# Incorrect trials, group-level:
ggplot(data = retrieval_mean_gaze %>%
         filter(is_correct == 0, !is.na(rolling_gaze_x), !is.na(new_time), !is.na(RECORDING_SESSION_LABEL)) %>%
         group_by(new_time, originTrialDir) %>%
         summarize(average_gaze_x = mean(rolling_gaze_x, na.rm = TRUE), .groups = "drop"), 
       aes(x = average_gaze_x, y = new_time, color = originTrialDir, group = originTrialDir)) +
  geom_line(alpha = 0.7) +  # Transparency for overlapping lines
  geom_smooth(method = "loess", se = FALSE) +  # Smoothing to reduce zigzags
  labs(
    title = "Gaze X Location of Incorrect Retrieval Trials",
    x = "Gaze X",
    y = "Time (ms)"
  ) +
  theme_Publication()

# Averaged dot-plot, correct trials: (each dot is an averaged timebin)
ggplot(retrieval_mean_gaze %>%
         filter(is_correct == 1, !is.na(rolling_gaze_x), !is.na(new_time), !is.na(RECORDING_SESSION_LABEL)) %>%
         group_by(new_time, originTrialDir) %>%
         summarize(average_gaze_x = mean(rolling_gaze_x, na.rm = TRUE)),
       aes(x = new_time, y = average_gaze_x)) +
  geom_point(aes(color = originTrialDir), size = 2) +
  coord_cartesian(expand = FALSE) +
  labs(title = "Averaged Gaze Coordinates During Correct Retrieval",
       x = "Time",
       y = "X Coordinate") + scale_y_reverse() +
  xlim(3500, 4500) + #ylim(600, 700) +
  theme_Publication()

# Dot plot by participant, incorrect trials:
ggplot(retrieval_mean_gaze %>%
         filter(is_correct == 0, !is.na(rolling_gaze_x), !is.na(new_time), !is.na(RECORDING_SESSION_LABEL)) %>%
         group_by(new_time, originTrialDir) %>%
         summarize(average_gaze_x = mean(rolling_gaze_x, na.rm = TRUE)),
       aes(x = new_time, y = average_gaze_x)) +
  geom_point(aes(color = originTrialDir), size = 2) +
  coord_cartesian(expand = FALSE) +
  labs(title = "Averaged Gaze Coordinates During Incorrect Retrieval",
       x = "Time",
       y = "X Coordinate") + scale_y_reverse() +
  xlim(3500, 4500) + #ylim(600, 700) +
  theme_Publication()

# Plots that have time information:
# Correct trials
ggplot(retrieval_mean_gaze %>%
         filter(is_correct == 1, !is.na(rolling_gaze_x), !is.na(new_time), !is.na(RECORDING_SESSION_LABEL)) %>%
         group_by(new_time, originTrialDir) %>%
         summarize(average_gaze_x = mean(rolling_gaze_x, na.rm = TRUE), average_gaze_y = mean(rolling_gaze_y, na.rm = TRUE)),
       aes(x = average_gaze_x, y = average_gaze_y)) +
  geom_point(aes(color = new_time), size = 2.5, alpha = 0.7) +  # Changed from encoding_position to new_time
  coord_cartesian(expand = FALSE) +
  facet_wrap(~originTrialDir) +
  labs(title = "Averaged Gaze Coordinates During Correct Retrieval",
       x = "X Coordinate",
       y = "Y Coordinate",
       color = "Time") +
  scale_y_reverse() +
  scale_color_viridis_c() + 
 # xlim(620, 675) +
  theme_Publication()

# Incorrect trials
ggplot(retrieval_mean_gaze %>%
         filter(is_correct == 0, !is.na(rolling_gaze_x), !is.na(new_time), !is.na(RECORDING_SESSION_LABEL)) %>%
         group_by(new_time, originTrialDir) %>%
         summarize(average_gaze_x = mean(rolling_gaze_x, na.rm = TRUE), average_gaze_y = mean(rolling_gaze_y, na.rm = TRUE)),
       aes(x = average_gaze_x, y = average_gaze_y)) +
  geom_point(aes(color = new_time), size = 2.5, alpha = 0.7) +  # Changed from encoding_position to new_time
  coord_cartesian(expand = FALSE) +
  facet_wrap(~originTrialDir) +
  labs(title = "Averaged Gaze Coordinates During Incorrect Retrieval",
       x = "X Coordinate",
       y = "Y Coordinate",
       color = "Time") +
  scale_y_reverse() +
  scale_color_viridis_c() + 
 # xlim(620, 675) +
  theme_Publication()
```

##Stats: (corr trials) Rolling Averages and gaze location by encoding order and position
```{r retrieval gaze location by encoding order and position, echo=FALSE, include=FALSE}
rolling_corr <- retrieval_mean_gaze %>% filter(is_correct == 1)

# 1. encoding order and mean gaze x at recall:
ret_meanx_order <- lmer(rolling_gaze_x~encoding_order + (1|RECORDING_SESSION_LABEL), data = rolling_corr)
summary(ret_meanx_order)
ref_ret_meanx_order <- summary(ret_meanx_order)

# 2. encoding location and mean gaze x at recall:
ret_meanx_location <- lmer(rolling_gaze_x~encoding_position + (1|RECORDING_SESSION_LABEL), data = rolling_corr)
summary(ret_meanx_location)
ref_ret_meanx_location <- summary(ret_meanx_location)

# 3. encoding direction and mean gaze x at recall:
ret_meanx_dir <- lmer(rolling_gaze_x~originTrialDir + (1|encoding_order) + (1|RECORDING_SESSION_LABEL), data = rolling_corr)
summary(ret_meanx_dir)
ref_ret_meanx_dir <- summary(ret_meanx_dir)

# 3. encoding order and location and mean gaze x at recall:
#ret_meanx_loc_order <- lmer(rolling_gaze_x~encoding_position*encoding_order + (1|RECORDING_SESSION_LABEL), data = rolling_corr)
#summary(ret_meanx_loc_order)

# Not averaged gaze values
corr_predec <- preDecision %>%
  filter(is_correct ==1)

# 4. trial direction and max gaze x at recall THIS IS NOT MAXIMUM!!
raw_x_order <- lmer(LEFT_GAZE_X~encoding_order  + (1|RECORDING_SESSION_LABEL), data = corr_predec)
summary(raw_x_order)
ref_raw_x_order <- summary(raw_x_order)

# 5. encoding location and max gaze x at recall:
raw_x_loc <- lmer(LEFT_GAZE_X~encoding_position + (1|encoding_order) + (1|RECORDING_SESSION_LABEL), data = corr_predec)
summary(raw_x_loc)
ref_raw_x_loc <- summary(raw_x_loc)

#check max vals
max_predec <- preDecision %>%
  filter(is_correct ==1) %>%
  group_by(RECORDING_SESSION_LABEL, TRIAL_INDEX, encoding_order, encoding_position) %>%
  summarize(max_x = max(LEFT_GAZE_X))

# 6. trial direction and max gaze x at recall THIS IS NOT MAXIMUM!!
ret_max_x_order <- lmer(max_x~encoding_order  + (1|RECORDING_SESSION_LABEL), data = max_predec)
summary(ret_max_x_order)
ref_ret_max_x_order <- summary(ret_max_x_order)

# 7. encoding location and max gaze x at recall:
ret_max_x_location <- lmer(max_x~encoding_position + (1|encoding_order) + (1|RECORDING_SESSION_LABEL), data = max_predec)
summary(ret_max_x_location)
ref_ret_max_x_location <- summary(ret_max_x_location)
```

**Gaze position during the retrieval phase**
**Rolling Averages and gaze location by encoding order and position**
We analyzed participants' gaze position to explore whether an the encoding order or position of an image influenced participant's gaze movements during successful retrieval trials.

First, we calculated rolling averages of gaze location for the period of time in which participants see a blank screen for one second, right after the offset of the retrieval image, and before the answer options appear on the screen. The rolling average was calculated by averaging five 5 consequent data points together (look at the explanation and explain better). We then explored whether gaze location on the x-axis interacted with the order or position in which the image was presented during the encoding phase.

**Encoding Order**
Gaze-X location on the screen was influenced by encoding order, such that for images presented second, participants looked more toward the right side of the screen ($\beta$ = `r round(ret_meanx_order@beta[3],3)`,  $p$ `r format_p(ref_ret_meanx_order$coefficients[2,5])`) and more toward the left side for images presented third, more to the left side of screen ($\beta$ = `r round(ret_max_x_location@beta[3],3)`,  $p$ `r format_p(ref_ret_max_x_location$coefficients[3,5])`), relative to images that were presented first. These differences are very small, only a few pixels (I am not sure how 2 pixel difference is significant, but it is!)

Overall (not averaged) maximum gaze locations were also influenced by encoding order. Participants looked more to the right side of the screen for retrieval images presented in second during encoding, ($\beta$ = `r round(ret_max_x_order@beta[2],3)`,  $p$ `r format_p(ref_ret_max_x_order$coefficients[2,5])`) and more to the left side of the screen for images presented on third during encoding ($\beta$ = `r round(ret_max_x_order@beta[3],3)`,  $p$ `r format_p(ref_ret_max_x_order$coefficients[3,5])`), relative to images that were presented on the left. 

**Encoding Position**
Gaze-X location on the screen was influenced by encoding position, such that participants looked more to the right side of the screen for retrieval images presented in the middle during encoding, ($\beta$ = `r round(ret_meanx_location@beta[2],3)`,  $p$ `r format_p(ref_ret_meanx_location$coefficients[2,5])`) and for images presented on the right during encoding ($\beta$ = `r round(ret_meanx_location@beta[3],3)`,  $p$ `r format_p(ref_ret_meanx_location$coefficients[3,5])`), relative to images that were presented on the left. 

Overall (not averaged) maximum gaze locations were also influenced by encoding position. Participants looked more to the right side of the screen for retrieval images presented in the middle during encoding, ($\beta$ = `r round(ret_max_x_location@beta[2],3)`,  $p$ `r format_p(ref_ret_meanx_location$coefficients[2,5])`) and for images presented on the right during encoding ($\beta$ = `r round(ret_max_x_location@beta[3],3)`,  $p$ `r format_p(ref_ret_meanx_location$coefficients[3,5])`), relative to images that were presented on the left. 

Raw data values, and maximum x coordinate values also show the same pattern. 

##Stats: Acc Comparison of Rolling Averages and gaze location by encoding order and position
```{r retrieval gaze location by encoding order and position, echo=FALSE, include=FALSE}

retrieval_mean_gaze$is_correct <- as.factor(retrieval_mean_gaze$is_correct)

# 1. encoding order and mean gaze x at recall:
acc_meanx_order <- lmer(rolling_gaze_x ~ encoding_order * is_correct + (1|RECORDING_SESSION_LABEL), data = retrieval_mean_gaze)
summary(acc_meanx_order)
ref_acc_meanx_order <- summary(acc_meanx_order)

# 2. encoding location and mean gaze x at recall:
acc_meanx_location <- lmer(rolling_gaze_x ~ encoding_position * is_correct + (1|encoding_order) + (1|RECORDING_SESSION_LABEL), data = retrieval_mean_gaze)
summary(acc_meanx_location)
ref_acc_meanx_location <- summary(acc_meanx_location)


# 4. trial direction and max gaze x at recall THIS IS NOT MAXIMUM!!
acc_raw_x_order <- lmer(LEFT_GAZE_X~encoding_order *is_correct + (1|RECORDING_SESSION_LABEL), data = preDecision)
summary(acc_raw_x_order)
ref_acc_raw_x_order <- summary(acc_raw_x_order)

# 5. encoding location and max gaze x at recall:
acc_raw_x_loc <- lmer(LEFT_GAZE_X~encoding_position *is_correct + (1|encoding_order) + (1|RECORDING_SESSION_LABEL), data = preDecision)
summary(acc_raw_x_loc)
ref_acc_raw_x_loc <- summary(acc_raw_x_loc)
```
###3) Displacement calculation
```{r gaze x displacement during predecision, echo=FALSE, include=FALSE}
displacement_x <- retrieval_phase %>%
  group_by(RECORDING_SESSION_LABEL, TRIAL_INDEX) %>%
  mutate(gaze_x_time = case_when(
         new_time == 3500 ~ "start",
         new_time == 4500 ~ "end")) %>%
  filter(!is.na(gaze_x_time))

displacement_x <- displacement_x %>%
  filter(!is.na(encoding_position))

dis_calc <- displacement_x %>%
  group_by(RECORDING_SESSION_LABEL, TRIAL_INDEX) %>%
  summarize(
    start_x = LEFT_GAZE_X[gaze_x_time == "start"][1],
    end_x   = LEFT_GAZE_X[gaze_x_time == "end"][1],
    displacement = end_x - start_x,
    .groups = "drop"
  ) %>%
  filter(!is.na(start_x), !is.na(end_x)) %>%
  arrange(RECORDING_SESSION_LABEL, TRIAL_INDEX)

displacement_x <- left_join(displacement_x, dis_calc, by = c("RECORDING_SESSION_LABEL", "TRIAL_INDEX")) %>%
  filter(!is.na(c(displacement)))

ggplot(displacement_x %>%
         filter(is_correct == 1),
         aes(x = encoding_order, y = displacement)) +
  geom_boxplot() +
  labs(title = "Gaze X by Encoding Order",
       x = "Encoding Order", y = "Gaze X Coordinate") +
  theme_Publication()

ggplot(displacement_x %>%
         filter(is_correct == 1), aes(x = encoding_position, y = displacement)) +
  geom_boxplot() +
  labs(title = "Gaze X by Encoding Position",
       x = "Encoding Position", y = "Gaze X Coordinate") +
  theme_Publication()

# Displacement by encoding order
ggplot(displacement_x %>%
         filter(is_correct == 1), aes(x = LEFT_GAZE_X, y = LEFT_GAZE_Y, color = gaze_x_time, group = TRIAL_INDEX)) +
  geom_point(alpha = 0.7, size = 2) + 
  geom_line(alpha = 0.5) +
  labs(
    title = "Gaze X Displacement, by order",
    x = "Gaze X",
    y = "Gaze Y"
  ) +
  facet_wrap(~encoding_order) +
  theme_Publication()

# Displacement by encoding position
ggplot(displacement_x %>%
         filter(is_correct == 1), aes(x = LEFT_GAZE_X, y = LEFT_GAZE_Y, color = gaze_x_time, group = TRIAL_INDEX)) +
  geom_point(alpha = 0.5, size = 2) + 
  geom_line(alpha = 0.5) +
  labs(
    title = "Gaze X Displacement, by position",
    x = "Gaze X",
    y = "Gaze Y"
  ) +
  facet_wrap(~encoding_position) +
  theme_Publication()

# Displacement by trial direction
ggplot(displacement_x %>%
         filter(is_correct == 1), aes(x = LEFT_GAZE_X, y = LEFT_GAZE_Y, color = gaze_x_time, group = TRIAL_INDEX)) +
  geom_point(alpha = 0.5, size = 2) + 
  geom_line(alpha = 0.5) +
  labs(
    title = "Gaze X Displacement, by trial direction",
    x = "Gaze X",
    y = "Gaze Y"
  ) +
  facet_wrap(~originTrialDir) +
  theme_Publication()
```

## Stats: Displacement gaze x location by encoding order and position
```{r retrieval gaze displacement by encoding order and position, echo=FALSE, include=FALSE}
displacement_x_corr <- displacement_x %>% filter(is_correct == 1)

# 1. encoding order and gaze x at recall:
disp_order <- lmer(displacement~encoding_order + (1|RECORDING_SESSION_LABEL), data = displacement_x_corr)
summary(disp_order)
ref_disp_order <- summary(disp_order)

# 2. encoding location and gaze x at recall:
disp_location <- lmer(displacement~encoding_position + (1|encoding_order) + (1|RECORDING_SESSION_LABEL), data = displacement_x_corr)
summary(disp_location)
ref_disp_location <- summary(disp_location)

# 3. trial direction and  gaze x at recall:
disp_direction <- lmer(displacement~originTrialDir  + (1|RECORDING_SESSION_LABEL), data = displacement_x_corr)
summary(disp_direction)
ref_disp_direction <- summary(disp_direction)

# 4. encoding order and location and gaze x at recall:
disp_loc_order <- lmer(displacement~encoding_position*encoding_order + (1|RECORDING_SESSION_LABEL), data = displacement_x_corr)
summary(disp_loc_order)
ref_disp_loc_order <- summary(disp_loc_order) 

# 5. encoding direction and order and gaze x at recall:
disp_dir_order <- lmer(displacement~originTrialDir*encoding_order + (1|RECORDING_SESSION_LABEL), data = displacement_x_corr)
summary(disp_dir_order)

# 6. encoding direction and location and gaze x at recall:
disp_dir_pos <- lmer(displacement~originTrialDir*encoding_position + (1|RECORDING_SESSION_LABEL), data = displacement_x_corr)
summary(disp_dir_pos)
```

## Stats: Accuracy comparison
```{r retrieval gaze displacement by encoding order and position, echo=FALSE, include=FALSE}

# 1. encoding order and gaze x at recall:
disp_order <- lmer(displacement~encoding_order*is_correct + (1|RECORDING_SESSION_LABEL), data = displacement_x)
summary(disp_order)
ref_disp_order <- summary(disp_order)

# 2. encoding location and gaze x at recall:
disp_location <- lmer(displacement~encoding_position*is_correct + (1|encoding_order) + (1|RECORDING_SESSION_LABEL), data = displacement_x)
summary(disp_location)
ref_disp_location <- summary(disp_location)

# 3. trial direction and  gaze x at recall:
disp_direction <- lmer(displacement~originTrialDir*is_correct + (1|RECORDING_SESSION_LABEL), data = displacement_x)
summary(disp_direction)
ref_disp_direction <- summary(disp_direction)

```
**Gaze displacement**
Next, we calculated the displacement in gaze X position starting at the timebin starting after the offset of the retrieval image, and the timebin right before the answer options appear, for correct trials. 

Here are some patterns:
Participants had a leftward displacement when retrieval image presented second in the triplet during encoding ($\beta$ = `r round(disp_order@beta[2],3)`,  $p$ `r format_p(ref_disp_order$coefficients[2,5])`). 

Participants had a rightward displacement when retrieval image presented on the right during encoding ($\beta$ = `r round(disp_location@beta[3],3)`,  $p$ `r format_p(ref_disp_location$coefficients[3,5])`). 

Participants had a leftward displacement when retrieval image came from a trial presented from righ to left ($\beta$ = `r round(disp_direction@beta[3],3)`,  $p$ `r format_p(ref_disp_direction$coefficients[3,5])`). 

Order and position interacted: Participants had a leftward displacement when retrieval image was on the right and presented second ($\beta$ = `r round(disp_loc_order@beta[7],3)`,  $p$ `r format_p(ref_disp_loc_order$coefficients[7,5])`) and was on the right and presented third ($\beta$ = `r round(disp_loc_order@beta[9],3)`,  $p$ `r format_p(ref_disp_loc_order$coefficients[9,5])`).
